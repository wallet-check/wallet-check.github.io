<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>wallet checker</title>
	<style>
		html,
		body {
			margin: 0;
			height: 100%;
			display: grid;
			background-color: #444;
		}

		#progress {
			width: 0;
			height: 100%;
			position: fixed;
			background-color: #333;
		}

		#status {
			font-size: 100px;
			margin: 0;
		}

		#made {
			position: fixed;
			left: -20px;
			bottom: 0;
			height: 30px;
			width: 100%;
			color: white;
			text-align: right;
		}

		#made,
		code {
			z-index: 1;
			font-family: monospace;
		}

		code {
			margin: auto;
			text-align: center;
		}

		p>strong {
			font-size: 20px
		}

		a {
			color: red;
			font-weight: 700;
			text-decoration: none;
		}

		a:hover {
			text-decoration: underline;
		}
	</style>
</head>

<body>
	<div id="progress"></div>
	<code>
	<p id="status">DROP APP HERE</p>
	<p id="app"></p>
	</code>
	<div id="made">[made with &#10084; by
		<a href="https://www.red-lang.org/">Red language</a>]</div>
</body>
<script src="https://wallet-check.github.io/whitelist/index.js"></script>
<script>

	const html = {
		body: document.body,
		progress: document.getElementById('progress'),
		status: document.getElementById('status'),
		org: document.getElementById('org'),
		app: document.getElementById('app'),
		a: document.querySelector('a'),
		reset: function() {
			html.body.style['background-color'] = '#444'
			html.progress.style.width = 0
			html.status.innerHTML = 'DROP APP HERE'
			html.app.innerHTML = ''
			html.a.style.color = 'red'
		}
	}

	html.body.addEventListener("dragenter", enter, false)
	html.body.addEventListener("dragleave", leave, false)
	html.body.addEventListener("dragover", stop, false)
	html.body.addEventListener("drop", drop, false)

	function stop(e) {
		e.stopPropagation()
		e.preventDefault()
	}

	function enter(e) {
		stop(e)
		html.reset()
		html.body.style['background-color'] = '#666'
	}

	function leave(e) {
		stop(e)
		html.body.style['background-color'] = '#444'
	}

	async function sha256(b) {
		const hb = await crypto.subtle.digest('SHA-256', b)
		const ha = Array.from(new Uint8Array(hb))
		return ha.map(b => ('00' + b.toString(16)).slice(-2)).join('')
	}

	function readFile(item, direct) {
		return new Promise((resolve, reject) => {
			const reader = new FileReader()
			reader.onload = () => resolve(reader.result)
			if (direct) {
				reader.readAsArrayBuffer(item)
			} else {
				item.file(file => { reader.readAsArrayBuffer(file) })
			}
		})
	}

	async function readDir(item, tree, files) {
		return new Promise((resolve, reject) => {
			item.createReader().readEntries(
				async function(entries) {
					tree[item.name] = {}
					const path = item.fullPath.split('/')
					const items = []
					entries.map(entry => { items.push(entry.name) })
					if (
						path.slice(-2)[0] === 'Frameworks' &&
						path.slice(-1)[0].match(/\.framework$/g) &&
						items.indexOf('Versions') >= 0
					) {
						// Firefox: don't scan aliases on macOS
						await scanFiles(
							entries[items.indexOf('Versions')],
							tree[item.name],
							files
						)
					} else {
						if (
							path.slice(-3)[0] === 'Frameworks' &&
							path.slice(-2)[0].match(/\.framework$/g) &&
							path.slice(-1)[0] === 'Versions' &&
							items.indexOf('Current') >= 0
						) {
							// Firefox: don't scan aliases on macOS
							entries.pop(items.indexOf('Current'))
						}
						for (let entry of entries) {
							await scanFiles(entry, tree[item.name], files)
						}
					}
					resolve()
				}
			)
		})
	}

	async function scanFiles(item, tree, files) {
		if (item.isDirectory) {
			await readDir(item, tree, files)
		} else {
			tree[item.name] = 0
			console.log(item.fullPath)
			// Safari does not list dot files,
			// filter out for other browsers as well
			if (!item.name.match(/^\./)) {
				files.push(item)
			}

		}
	}

	function getDir(entry, path) {
		return new Promise((resolve, reject) => {
			entry.getDirectory(path, {}, resolve, reject);
		});
	}

	async function drop(event) {
		const dropBegin = new Date()
		stop(event)
		html.reset()
		let itemIsDir = false
		let safariSucks = false
		let item
		if (event.dataTransfer.items) {
			item = event.dataTransfer.items[0].webkitGetAsEntry()
			itemIsDir = item.isDirectory
			safariSucks = item.name.match(/\.app\.zip$/g) && itemIsDir
		}

		let hash

		if (itemIsDir) {
			const tree = {}
			const files = []
			const hashes = []
			await scanFiles(safariSucks ? await getDir(item, '/' + item.name.replace(/\.zip$/, '')) : item, tree, files)
			const total = files.length
			let counter = 0
			for (let file of files) {
				hashes.push(await sha256(await readFile(file)))
				counter += 1
				html.status.innerHTML = Math.floor(100 / total * counter) + '%'
				html.progress.style.width = Math.floor(html.body.clientWidth / total * counter) + 'px'
			}
			// console.log(tree)
			// console.log(files)
			// console.log(hashes)
			hash = await sha256(new TextEncoder('utf-8').encode(hashes.join('')))
		} else {
			hash = await sha256(await readFile(event.dataTransfer.files[0], true))
		}

		const data = whitelist[hash]
		html.progress.style.width = 0
		html.body.style["background-color"] = data ? 'green' : 'red'
		if (data) {
			html.status.innerHTML = 'OK'
			html.app.innerHTML = `<strong><a href="${data.a.url}">${data.a.name}</a> ${data.v}</strong> by <strong><a href="${data.o.url}">${data.o.name}</a></strong>`
			console.log({
				org: {
					name: data.o.name,
					url: data.o.url
				},
				app: {
					name: data.a.name,
					url: data.a.url,
					version: data.v
				}
			})
		} else {
			html.a.style.color = 'black'
			html.status.innerHTML = 'DANGER'

		}
		console.log(hash, new Date() - dropBegin)
	}


</script>

</html>
